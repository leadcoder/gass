float3 calcVertexLight(float3 normal,float3 lightDir,float3 halfAngle,float3 lightDiffuse,float3 lightSpecular, float exponent)
{
	
	float NdotL = dot(normalize(lightDir), normal);
	float NdotH = dot(normalize(halfAngle), normal);
	float4 Lit = saturate(lit(NdotL,NdotH,exponent));
	float3 col = lightDiffuse * Lit.y + lightSpecular * Lit.z;
	return col;
}

/*
  Four-weight-per-vertex hardware skinning, 2 lights
  The trouble with vertex programs is they're not general purpose, but
  fixed function hardware skinning is very poorly supported
*/
void hardwareSkinningFourWeights_vp(
	float3 position : POSITION,
	float3 normal   : NORMAL,
	float2 uv       : TEXCOORD0,
	float4 blendIdx : TEXCOORD2,
	float4 blendWgt : TEXCOORD1,
	out float4 oPosition : POSITION,
	out float2 oUv       : TEXCOORD0,
	out float4 colour           : COLOR,
	// Support up to 24 bones of float3x4
	// vs_1_1 only supports 96 params so more than this is not feasible
	uniform float3x4   objectMatrix3x4Array[40],
	uniform float4x4 worldViewProj,
	uniform float4 lightPos,
    uniform float3 eyePos,
	uniform float4 specular,
	uniform float4 diffuse,
	uniform float exponent,
	uniform float4 ambient)
{
	// transform by indexed matrix
	float4 blendPos = float4(0,0,0,0);
	float4 inPos = float4(position.x,position.y,position.z,1);
	int i;
	for (i = 0; i < 4; ++i)
	{
		blendPos += float4(mul(objectMatrix3x4Array[blendIdx[i]], inPos).xyz, 1.0) * blendWgt[i];
	}
	// view / projection
	oPosition = mul(worldViewProj, blendPos);
	
	// calc normal
	float3 blendNorm = float3(0,0,0);
	for (i = 0; i < 4; ++i)
	{
		blendNorm += mul((float3x3)objectMatrix3x4Array[blendIdx[i]], normal) * blendWgt[i];
	}
	blendNorm = normalize(blendNorm);
	
	oUv = uv;
	float3 lightDir = normalize(lightPos.xyz -  (blendPos.xyz * lightPos.w).xyz);
	float3 eyeDir = eyePos.xyz - blendPos.xyz; 
	eyeDir = normalize(eyeDir);
	float3 halfAngle = normalize(eyeDir + lightDir); 
	colour = ambient + float4(calcVertexLight(blendNorm,lightDir,halfAngle,diffuse.xyz,specular.xyz,exponent),1);
}

void diffuse_one_light_cal3d_skinning_vp(
	     float3 position   : POSITION 
	    ,float3 normal      : NORMAL
	    ,float2 uv         : TEXCOORD0 
   	    ,float4 blendIdx : TEXCOORD2
		,float4 blendWgt : TEXCOORD1
       
        // outputs 
        ,out float4 oPosition    : POSITION
        ,out float2 oUv          : TEXCOORD0
        ,out float4 oEyeDir       : TEXCOORD1
#ifndef LIGHT_MAP 
        ,out float3 oLightDir    : TEXCOORD2 
		,out float3 oSpotDirection : TEXCOORD3
		,out float3 oNormal :  TEXCOORD4
		,out float3 oHalfAngle:  TEXCOORD5
#endif
#ifdef INTEGRATED_SHADOWS
        ,out float4 oShadowUV : TEXCOORD6
#endif
		// parameters 
		,uniform float4 lightPosition // world space 
        ,uniform float3 eyePosition   // world space 
        ,uniform float3 spotDirection // world space
        ,uniform float4x4 worldViewProj
#ifdef INTEGRATED_SHADOWS
	#ifdef LINEAR_RANGE
		  ,uniform float4 shadowDepthRange
	#endif
		  //,uniform float4x4 worldMatrix
		  ,uniform float4x4 texWorldViewProj 
#endif
		,uniform float3x4 objectMatrix3x4Array[40]
		,uniform float4x4 textureMatrix
		)
{  
    //calculate output position 
    float4 blendPos = float4(0,0,0,0);
	float4 inPos = float4(position.x,position.y,position.z,1);
	int i;
	for (i = 0; i < 4; ++i)
	{
		blendPos += float4(mul(objectMatrix3x4Array[blendIdx[i]], inPos).xyz, 1.0) * blendWgt[i];
	}
	
    oPosition = mul(worldViewProj, blendPos); 
	float4 obj_pos =  blendPos; 
   
   float3 eyeDir = eyePosition.xyz - position.xyz; 
   oEyeDir.w =  length(eyeDir);
   eyeDir = normalize(eyeDir);
   oEyeDir.xyz = eyeDir;
   
#ifndef LIGHT_MAP
    float3 lightDir = normalize(lightPosition.xyz -  (obj_pos.xyz * lightPosition.w).xyz);
   
	float3 blendNorm = float3(0,0,0);
	for (i = 0; i < 4; ++i)
	{
		blendNorm += mul((float3x3)objectMatrix3x4Array[blendIdx[i]], normal) * blendWgt[i];
	}
	blendNorm = normalize(blendNorm);
	 

   oNormal = blendNorm;
   oLightDir = lightDir; 
   oHalfAngle = normalize(eyeDir + lightDir); 
   oSpotDirection = normalize(-spotDirection);
#endif
#ifdef INTEGRATED_SHADOWS
   oUv = mul(textureMatrix,float4(uv,0,1)).xy;
   oShadowUV = mul(texWorldViewProj, blendPos);
   #ifdef LINEAR_RANGE
   oShadowUV.z = (oShadowUV.z - shadowDepthRange.x) * shadowDepthRange.w;
   #endif
#endif 
}


void hardwareSkinningFourWeightsShadow_vp(
	float3 position : POSITION,
	float3 normal   : NORMAL,
	float2 uv       : TEXCOORD0,
	float4 blendIdx : TEXCOORD2,
	float4 blendWgt : TEXCOORD1,
	out float4 oPosition : POSITION,
	out float2 oUv       : TEXCOORD0,
	out float4 colour           : COLOR,
	uniform float3x4 objectMatrix3x4Array[40],
	uniform float4x4 worldViewProj)
{
	float4 blendPos = float4(0,0,0,0);
	float4 inPos = float4(position.x,position.y,position.z,1);
	int i;
	for (i = 0; i < 4; ++i)
	{
		blendPos += float4(mul(objectMatrix3x4Array[blendIdx[i]], inPos).xyz, 1.0) * blendWgt[i];
		
	}
	oPosition = mul(worldViewProj, blendPos);
	oUv.x = oPosition.z;
	oUv.y = oPosition.w;
	colour = float4(1,1,1,1);
}
